<html>
<head>
  <meta charset="utf-8">
  <title>Hello Pixi</title>
</head>
<script src="jointjs/dagre.min.js"></script>
<script src="jointjs/graphlib.min.js"></script>
<script src="jointjs/jquery.min.js"></script>
<script src="jointjs/lodash.min.js"></script>
<script src="jointjs/backbone.js"></script>
<script src="jointjs/joint-3.0.2.min.js"></script>
<script src="pixi.min.js"></script>
<script src="py_trees.js"></script>
<link rel="stylesheet" type="text/css" href="jointjs/joint-3.0.2.min.css"/>
<style>
  body {
    margin: 0;
  }
</style>
<body>
  <div id="foo"></div>
  <script type="text/javascript">
    // Hello to the JS console
    let type = "WebGL"
    if(!PIXI.utils.isWebGLSupported()){
      type = "canvas"
    }
    PIXI.utils.sayHello(type)
    console.log("JointJS: %s", joint.version)
  </script>
  <div id="myholder"></div>
  <script type="text/javascript">
    // Additionally, the graph accepts an option object in its constructor function that can contain the cellNamespace option.
    //
    // This option can be used to change the default behavior of JointJS which by default reads cell model definitions
    // from the joint.shapes namespace. For example, if a cell is of type 'myshapes.MyElement', then the graph looks up
    // joint.shapes.myshapes.MyElement model when deserializing a graph from the JSON format. If the graph is instantiated as
    // e.g. var graph = new joint.dia.Graph({}, { cellNamespace: myShapesNamespace }), then the graph will read the model
    // definition from the myShapesNamespace.myshapes.MyElement object instead.
    //
    // This is useful in situations where you don't want to - for any reason -
    // use the joint.shapes namespace for defining your own custom shapes. This option is often used in combination with the
    // cellNamespaceView option on the joint.dia.Paper object.
    var graph = new joint.dia.Graph;

    var paper = new joint.dia.Paper({
        el: document.getElementById('myholder'),
        model: graph,
        width: '100%',
        height: '100%',
        // defaultConnector: {  // doesn't seem to have any effect
        //     name: 'rounded',
        //     args: {
        //         radius: 20
        //     }
        // },
        background: {
            color: '#000000',
        },
        gridSize: 1
    });
    parallel = py_trees.parallel({ name: "Root", message: "Dude" })
    parallel.addTo(graph);

    joint.shapes.custom = {};
    joint.shapes.custom.Element = joint.dia.Element.extend({
      defaults: _.defaultsDeep({
        type: 'custom.Element',
        fillColor: 'red',
        outlineColor: 'black',
        activeTab: 0,
        numberOfTabs: 1,
        faded: false
      })
    });

    joint.shapes.custom.ElementView = joint.dia.ElementView.extend({

      events: {
        'dblclick': 'onDblClick',
        'click .tab': 'onTabClick'
      },

      init: function() {
        var model = this.model;
        this.listenTo(model, [
          'change:activeTab',
          'change:fillColor',
          'change:outlineColor',
        ].join(' '), this.update);
        this.listenTo(model, 'change:faded', this.toggleFade);
        this.listenTo(model, 'change:numberOfTabs', this.render);
      },

      render: function() {
        var markup = this.constructor.markup;
        var body = this.vBody = markup.body.clone();
        var tabs = this.vTabs = [];
        var texts = this.vTexts = [];
        for (var i = 0, n = this.model.prop('numberOfTabs'); i < n; i++) {
          tabs.push(markup.tab.clone());
          texts.push(markup.text.clone().text('Tab ' + (i + 1)));
        }
        this.vel.empty().append(
          _.flatten([
            body,
            tabs
          ])
        );
        this.translate();
        this.update();
      },

      update: function() {
        this.updateBody();
        this.updateText();
        this.updateTabs();
        this.toggleFade();
      },

      updateBody: function() {
        var model = this.model;
        var bodyAttributes = {
          width: model.prop('size/width'),
          height: model.prop('size/height'),
          fill: model.prop('fillColor'),
          stroke: model.prop('outlineColor')
        };
        this.vBody.attr(bodyAttributes);
      },

      updateTabs: function() {
        var model = this.model;
        var numberOfTabs = model.prop('numberOfTabs');
        var length = model.prop('size/width') / numberOfTabs;
        var activeTab = model.prop('activeTab');
        var vTabs = this.vTabs;
        for (var i = 0; i < numberOfTabs; i++) {
          var isActive = (activeTab === i);
          var offset = +isActive;
          vTabs[i].attr({
            width: length - 2 * offset,
            x: i * length + offset,
            y: offset,
            height: 20,
            stroke: (isActive) ? 'none' : model.prop('outlineColor'),
            fill: (isActive) ? model.prop('fillColor') : 'gray',
            'data-index': i
          });
        }
      },

      updateText: function() {
        var model = this.model;
        var activeTab = model.prop('activeTab');
        var numberOfTabs = model.prop('numberOfTabs');
        var vTexts = this.vTexts;
        for (var i = 0; i < numberOfTabs; i++) {
          var vText = vTexts[i];
          if (i === activeTab) {
            var tx = model.prop('size/width') / 2;
            vText.attr({
              transform: 'translate(' + tx + ',30)',
              'text-anchor': 'middle'
            });
            this.vel.append(vText);
          } else {
            vText.remove();
          }
        }
      },

      toggleFade: function() {
        this.vel.attr('opacity', this.model.prop('faded') ? 0.2 : 1);
      },

      onTabClick: function(evt) {
        var index = +V(evt.target).attr('data-index');
        this.model.prop('activeTab', index);
      },

      onDblClick: function() {
        this.model.prop('faded', !this.model.prop('faded'));
      }

    }, {

      markup: {
        body: V('rect').addClass('body'),
        tab: V('rect').addClass('tab'),
        text: V('text').addClass('text')
      }

    });

    links = []
    _.times(4, function(i) {
      var custom_element = new joint.shapes.custom.Element;
      custom_element
        .prop('numberOfTabs', i)
        .resize(100, 100)
        .position(50 + (i % 2) * 150, 50 + (i < 2) * 150)
        .prop('fillColor', ['salmon', 'lightgreen', 'lightblue', 'lightgray'][i])
        .prop('faded', i === 1)
        .addTo(graph);
      var link = new joint.shapes.standard.Link();
      link.source(parallel)
      link.target(custom_element)
      link.connector('smooth');
      link.addTo(graph)
      links.push(link)
    });

    // paper.scale(0.5, 0.5); // the api to enable zooming

    var graph_bounding_box = joint.layout.DirectedGraph.layout(graph, {
        marginX: 50,
        marginY: 50,
        nodeSep: 50,
        edgeSep: 80,
        rankDir: "TB"
    });
    console.log('x:', graph_bounding_box.x, 'y:', graph_bounding_box.y)
    console.log('width:', graph_bounding_box.width, 'height:', graph_bounding_box.height);
  </script>
</body>
</html>
